# Kubernetes

## 1. Summary

### 1) 가상화 History

- 가상 머신

![1](https://user-images.githubusercontent.com/37721713/70195667-a8302380-1749-11ea-9403-623812d751a9.PNG)

```
가상 머신 자체는 완전한 컴퓨터라 항상 게스트 OS를 설치

이미지 안에 OS가 포함되기 때문에 이미지 용량이 큼

가상화 소프트웨어는 OS를 가상화하는 것에만 초점(배포와 관리 기능이 부족)

```

- chroot

![3](https://user-images.githubusercontent.com/37721713/70195670-a8c8ba00-1749-11ea-989e-255e73d299d8.PNG)

```
chroot는 파일시스템에서 루트 디렉터리(/)를 변경하는 명령

chroot로 특정 디렉터리를 루트 디렉터리로 설정하면 chroot jail(감옥)이라는 환경이 생성되는데, chroot jail안에서는 바깥의 파일과 디렉터리에 접근할 수 없음 

chroot는 디렉터리 경로를 격리하기 때문에 서버 정보 유출과 피해를 최소화 하는데 주로 사용됨

chroot는 chroot jail에 들어갈 실행 파일과 공유 라이브러리를 직접 준비해야 하고 설정 방법이 복잡 

완벽한 가상 환경이 아니기 때문에 각종 제약이 많았고, 이후 리눅스는 LXC(LinuX Container)라는 시스템 레벨 가상화를 제공
```

- 리눅스 컨테이너(LXC) - cgroup, namespace

![4](https://user-images.githubusercontent.com/37721713/70195671-a9615080-1749-11ea-8a47-ab30c3f06b21.PNG)

```
LXC는 컴퓨터를 통째로 가상화하여 OS를 실행하는 것이 아닌 리눅스 커널 레벨에서 제공하는 일종의 격리(Isolate)된 가상 공간

가상공간에는 OS가 설치되지 않기 때문에 가상 머신이라 하지 않고, 컨테이너라 명명

리눅스 커널의 Control Groups(cgroups)는 CPU, 메모리, 디스크, 네트워크 자원을 할당하여 완전한 형태의 가상 공간을 제공 

또한, 프로세스 트리, 사용자 계정, 파일시스템, IPC 등을 격리시켜 호스트와 별개의 공간을 만드는데 이것을 Namespace isolation(namespaces)이라고 함.

LXC는 리눅스 커널의 cgroups와 namespaces 기능을 활용하여 가상 공간을 제공
```

- Docker

![2](https://user-images.githubusercontent.com/37721713/70195669-a8c8ba00-1749-11ea-8c45-7b85d8107db1.PNG)

```
Docker 이미지에 서버 운영을 위한 프로그램과 라이브러리만 격리해서 설치할 수 있고, OS 자원(시스템 콜)은 호스트와 공유

Docker는 하드웨어를 가상화하는 계층이 없기 때문에 메모리 접근, 파일시스템, 네트워크 속도가 가상 머신에 비해 월등히 빠름

Docker는 가상 머신과는 달리 이미지 생성과 배포에 특화된 기능을 제공

이미지 버전 관리 기능을 제공

중앙 관리를 위해 저장소에 이미지를 올리고, 받을 수 있음(Push/Pull)

다양한 API를 제공하기 때문에 원하는 만큼 자동화를 할 수 있어 개발과 서버 운영에 매우 유용
```

### 2) 컨테이너 기술이 주목을 받은 이유

```
큰 회사들은 대규모의 서비스를 운영하고 있기 때문에 최대한 자원을 효율적으로 써야 비용적으로 유리

가상화 SW 기술들이 생각보다 시스템 효율이 안남(가장 큰 원인은 VM가상화를 하기 위해 무거운 OS를 띄워야 하는 근본적 문제)

dotCloud라는 회사에서 2014년 Container(가상화기술)을 선보임(추후 Docker로 회사명 변경)

컨테이너 가상화 기술은 서비스간에 자원격리를 하는데 OS를 별도로 안 띄워도 됨

OS기동시간이 없기 때문에 자동화시 빠르고 자원 효율 또한 매우 높음
```

### 3) 컨테이너 오케스트레이터의 필요성

```
Docker 자체는 하나의 서비스를 컨테이너로 가상화시켜서 배포를 하는것에 목적

Docker는 엄청 많은 서비스를 운영할 때 그것을 일일히 배포하고 운영하는 역할을 하진 않음

여러 컨테이너들을 관리하는 솔루션이 필요했고, 이것이 컨테이너 오케스트레이터

오케스트레이터에는 도커스웜, 랜처, Hashi Corp Nomad, K8s가 대표적

k8s가 늦게 릴리즈 되었으나 해당 프로젝트에 참여하는 기업들(레드햇, MS, IBM, Docker, MESOSPHERE 등)이 자신들의 노하우를 녹여내면서 퀄리티가 매우 높음

현재 K8S가 하나의 표준처럼 사용됨
```

## 2. Why K8S?
기업입장에서 새로운 서비스를 런칭하거나(예를 들어 게임) 여러 서비스를 동시에 운영하는 경우 트래픽에 대한 예측이 어렵고, 충분한 리소스를 사전에 확보하는 것도 어렵다.

기존의 운영방식은 서비스에 따라 수용할 수 있는 서버 자원을 확보해 놓는 반면, 쿠버네티스는 auto scling을 통해 트래픽이 높아지는 서비스에 대해서만 자원 할당을 늘릴 수 있다. 즉, 더 적은 서버자원으로도 원활한 서비스를 제공할 수 있음.
기존 시스템에 장애가 나는 경우 여분의 백업 서버가 있어 운영서버가 죽는경우 즉각 대응을 하는데 쿠버네티스가 적용된 서비스는 장애가 난 서버 위에 있는 서비스들이 다른 서버로 옮겨갈 수 있는 auto healing 기능이 있다.
버전을 올리는 경우는 중단이 가능하다면 모든 서버를 중지하고 한번에 업데이트를 하거나 무중단이 안되면 하나씩 서버를 업데이트 해야한다. 하지만 쿠버네티스 기반의 시스템은 Deployment라는 오브젝트(RollingUpdate, ReCreate)를 통해 자동으로 업데이트를 지원한다.
쿠버네티스 사용시 서비스 효율이 좋아지고 비용을 감소할 수 있다.

## 3. VM vs Container
VM : Host OS 위에 vm을 가상화하기 위해 Hypervisor(VMware, Xen, KVM 등)가 올라가고, 그 위해 Guest OS가 다시 올라가고, 그 위에 여러 어플리케이션을 설치하여 서비스 제공을 하는 방식.

Container : Host OS 위에 컨테이너 가상화를 지원하는 Docker, rkt, LXC와 같은 소프트웨어를 설치하고, 이 위에 컨테이너가 올라가게 된다.
도커는 여러 컨테이너들 간에 호스트 자원을 분리해서 사용할 수 있게한다. 이것이 리눅스 고유 기술인 namespace(mnt, pid, net, ipc, uts, user - 커널에 대한 영역을 분리)와 cgroups(memory, CPU, I/O, network - 자원에 대한 영역을 분리)를 사용하는 것이다.
단점 : vm은 윈도우를 사용하더라도 리눅스 guest os를 설치하면 리눅스 사용이 가능하다. 하지만 컨테이너는 리눅스에서 윈도우용 컨테이너를 사용할 수 없다. 또한 보안적으로도 vm은 하나의 guest os가 뚫려도 다른 guest os와 완벽히 분리가 되어 있기 때문에 각각의 vm끼리 피해가 가지 않지만, 컨테이너는 하나의 컨테이너가 뚫려 host os 영역에 접근을 하게되면 다른 컨테이너들에게 영향을 미칠 수 있다. 

## 4. Getting started - k8s

## 5. Overview
쿠버네티스는 서버한대는 master로 쓰고 다른 서버들은 node라고 해서 마스터에 여러 노드들이 연결이 된다. 이런 연결을 쿠버네티스 클러스터라고 한다.
master는 쿠버네티스의 전반적인 기능을 컨트롤하는 역할.
node들은 자원을 제공하는 역할.
클러스터 전체 자원을 늘리고 싶다면 노드들을 계속 추가하면된다.
클러스터 안에 namespace라는 것이 쿠버네티스 오브젝트들을 독립된 공간으로 분리되게 만들어 준다. namespace에는 쿠버네티스 최소 배포단위이 pod들이 있고, 이 pod들에게 외부에서 연결이 가능하도록 ip를 할당해 주는 service가 있다. 
서로 다른 namespace에 있는 pod는 연결할 수 없다. 
pod안에는 여러 컨테이너가 존재할 수 있다. 컨테이너 하나당 하나의 어플리케이션이 동작하기 때문에 결국 pod에는 여러 어플리케이션이 돌아갈 수 있다. 
하지만 pod에 문제가 생겨서 재생성이되면 그 안에 있는 데이터가 날아가게 되는데, volume을 사용하면 이곳에 데이터를 저장할 수 있다. 따라서 pod가 재생성되어도 데이터의 유지가 가능하다. 
namespace에 ResourceQuota/LimitRange를 달아서 namespace에서 사용할 수 있는 자원의 양을 한정시킬 수 있다. pod개수 제한, cpu나 메모리 제한도 가능
pod생성시에 컨테이너 안에 환경변수 값을 넣어주거나 파일을 마운팅할 수 있는데 ConfigMap/Secret을 사용하면 된다.
또한 Controller가 pod들을 관리하는 역할을 하게 되는데 종류가 여러가지가 있음.
Replication Controller, ReplicaSet은 가장 기본적인 컨트롤러이며 pod가 죽으면 감지해서 다시 재생성하거나 pod의 개수를 늘리거나 줄일 수 있다.
Deployment는 배포 후의 pod들을 새 벼전으로 업그레이드 해준다. 업그레이드 중 문제가 생기면 롤백을 쉽게할 수 있도록 도와준다.
DaemonSet은 한 노드에 pod가 하나씩만 유지가 되도록 한다.
CronJob은 어떤 특정 작업만 하고 종료시켜야하는경우 pod가 그 역할을 수행할 수 있도록 한다.

## 6. Pod
Pod 안에는 독립적인 서비스를 구동할 수 있는 컨테이너가 존재.
컨테이너들은 서비스가 연결될 수 있도록 포트를 가지고 있는데 한 컨테이너가 하나 이상의 포트를 사용할 수 있지만, 한 Pod 안에서 컨테이너들끼리 포트가 중복될 수 없다. 
Pod 내에서는 localhost 통신을 할 수 있음.
Pod 생성시 고유의 ip가 랜덤하게 할당되는데 쿠버네티스 클러스터 내에서만 해당 ip로 접근할 수 있다. (재생성시 변경됨. 즉 휘발성) . 외부에서는 pod의 ip로 직접접근이 안된다.

Label속성 : pod뿐만 아니라 모든 쿠버네티스 오브젝트에 달 수 있지만, pod를 정의할 때 가장 많이 사용된다. Lable을 사용하는 이유는 목적에 따라 오브젝트를 분류하고, 그 분류된 오브젝트들만 연결하기 위함이다. 
key:value 형태로 구성됨. 한 pod에는 여러개의 label을 달 수 있다. 
원하는 pod를 선택해서 service에서 따로 구성하여 사용하는 것이 가능하다. Service에서 selector를 사용해서 pod의 label을 구분지으면 됨.

Node Schedule : pod는 여러 노드중 한 노드에 올라가야하는데 직접 지정하는 방법과 쿠버네티스가 자동으로 지정하는 방법이 있다.

직접 지정하는 방법 : pod에 label을 단 것 처럼 node에 label을 달고 pod를 만들때 노드를 지정할 수 있다. nodeSelector를 사용하면 됨.

쿠버네티스의 스케줄러가 자동으로 지정하는 방법 : 쿠버네티스 스케줄러가 생성되는 pod의 리소스를 고려하여 여러 노드 중 가장 적합한 노드에 스케줄링한다.

## 7. Service
자신의 클러스터 ip를 가지고 있고, Service를 pod에 연결시켜 놓으면 Service ip를 통해서 pod에 접근할 수 있다. 
pod라는 존재는 언제던지 죽을 수 있고 다시 재생성되도록 설계되어 있는 오브젝트이다. 따라서 해당 pod가 죽고, 재생성되면 ip 할당 또한 달라진다.(신뢰성이 떨어짐)
service는 사용자가 삭제하는 것이 아닌 이상 삭제 되지 않기 때문에, Service를 사용한다.

ClusterIP : Cluster내에서만 접근 가능한 IP이다.(외부에서 직접 접속을 못함)
pod를 여러개 연결할 수 있는데, 여러개 연결시 service가 트래픽을 분산하여 pod에 전달한다.
외부에서 접근할 수 없고 클러스터 내부에서만 접근가능.
인가된 사용자(운영자), 내부 대시보드, pod의 서비스 상태 디버깅 용도로 사용

NodePort : Service에는 clusert ip가 할당이된다. 쿠버네티스 클러스터에 연결된 모든 노드에게 똑같은 포트가 할당되어 외부로부터 어떤 노드던 간에 ip와 포트로 접속을 하면 해당 service에 접속을 하고, 이 트래픽을 pod에 전달한다. 
모든 노드들에 포트가 할당되는 것이 특징이다.
물리적인 호스트의 ip를 통해서 pod에 접근이 가능. 일반적으로 물리적인 ip는 내부망에서만 접근할 수 있게 네트워크를 구성함.
내부망 연결, 데모나 임시 연결용

Load Balancer : Load balancer가 노드에 접근하는 트래픽을 분산을 해주어야 한다. Load Balancer에 접근을 하기 위한 외부 접속 ip는 쿠버네티스 설치만으로는 생성되지 않는다. 따라서 별도의 외부접속 ip를 할당해주는 플러그인이 설치되어 있어야 해당 ip가 생긴다.
내부 ip가 노출되지 않고 외부 ip를 통해 안정적으로 서비스를 노출하기 위한 용도임.
외부시스템 노출용.

## 8. Volume
emptyDir : 컨테이너들끼리 데이터를 공유하기 위해 volume을 사용하는 것.
volume은 pod 생성시 만들어지고 삭제시 없어진다.(pod안에 생성되는 volume이기 때문)
따라서 일시적인 사용목적에 의한 데이터만 넣어야 한다.

hostPath : pod들이 올라가 있는 Node의 path를 volume으로 사용.
Node 안에 생성되는 volume이기 때문에 pod들이 재생성되어도 영향을 받지 않는다. 
하지만 pod가 재생성될때 특정 노드에만 재생성 되는 것이 아닌, 스케줄러에 의해 가장 적합한 노드에 생성될 수도 있는데, 이러면 이전의 volume에 접근할 수 없다. 
hostpath이기 때문에 자신의 pod가 올라가있는 node의 volume만 사용하므로 다른 노드의 voluem을 마운트를 할 수가 없다. 하지만 굳이 방법을 찾는다면, 노드가 추가가 될 때마다 같은 이름의 경로를 만들어서 직접 노드에 있는 path끼리 마운트를 시켜주면 문제는 없어질 수 있다. 이 부분은 운영자가 직접 마운트를 연결해주어야 함.
각각의 노드에는 노드 자신들을 위해 사용되는 파일이 있을텐데 (시스템 파일, 설정파일 등) pod 자신이 할당되어 있는 호스트에 데이터를 읽거나 써야할 때 사용하면 된다. 
pod 생성전에 path가 미리 만들어져있어야 한다.(주의할점)

PVC(Persistent Volume Claim) / PV(Persistent Volume) : pod의 영속성있는 볼륨을 제공하기 위한 기능.

Pod -> Persistent Volume Claim -> Persistent Volume -> Volume(git, local storage 등)

직접 만들고 관리하는 솔루션(스토리지)을 각각 Persistent Volume을 정의하고 연결을 한다. 
Pod는 PV에 바로 연결하는 것이 아닌 PVC를 거쳐야 한다. 
PVC를 거치는 이유는 Volume 사용에 있어 user 영역(pod, PVC)과 admin 영역(PV, Volume)을 나누었기 때문이다.
admin은 쿠버네티스를 담당하는 운영자, user는 pod에 서비스를 만들고 배포를 관리하는 서비스 담당자.

## 9. ConfigMap, Secret

Dev환경과 Production 환경이 있을 때, 특정 서비스가 인증을 필요로 한다. 이때 개발환경에서는 인증을 꺼놓고 개발 및 테스트를 진행할 수 있지만, 실제 프로덕션 환경에서는 인증 모듈이 실행되어야 한다. 즉 특정 옵션과 유저의 키값 등이 바뀌어야 한다. 특정 이미지에서 제공되는 값을 바꾸는 것이기 때문에 개발환경과 프로덕션 환경에서 사용되는 이미지가 다르게 되고, 별도로 관리하는 등의 리소스가 낭비가 된다. 
환경에 따라 변하는 값들은 외부에서 결정할 수 있게 하는데, 그것을 도와주는 것이 ConfigMap과 Secret이다.
일반적인 상수들을 모아서 ConfigMap을 만들고 키처럼 보안이 필요한 것들은 Secret으로 관리를 한다. Pod를 생성하는 시점에 이 두 값을 연결을 하게 되면, 컨테이너의 환경변수에 해당 데이터들이 들어가게 된다. 따라서 서비스는 환경변수의 값을 읽어서 개발/상용 환경에 따른 옵션을 설정할 수 있다. 

ConfigMap과 Secret을 사용할 때에는 Literal(상수)과 File 형태로 사용할 수 있다. File은 Volume Mount 형태로 사용을 해야 한다. 
Secret은 value를 만들때 Base64를 기반으로 만드는데 실제 Pod에서 사용될 때에는 decoding되어 사용된다. Secret의 보안적인 부분은 일반적으로 쿠버네티스에서 사용되는 값은 데이터베이스에 저장이 되나 Secret은 메모리에 저장이 되고 1Mbyte 이하의 크기여야 한다. ConfigMap은 key:value 형태로 무제한 만들 수 있다. 


File을 환경변수에 넣는방법은 파일 자체가 ConfigMap, Secret의 Key가 될 수 있다. 파일명은 Key가 되고 그 안의 내용이 value가 됨.
이것을 Pod의 환경변수에 넣을 때 파일의 내용만 따로 넣어줘야 한다.
kubectl create configmap cm-file --from-file=./file.txt
kubectl create secret generic sec-file --from-file=./file.txt
위의 형태를 사용해서 파일에서 내용만 가져와 ConfigMap, Secret을 만들 수 있다.
Secret을 만드는 경우 file의 내용이 Base64로 바뀌므로 주의해야 한다.

