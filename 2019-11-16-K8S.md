# Kubernetes

## 1. Summary
쿠버네티스를 큰 회사들이 꼭 써야하는 이유 : 큰 회사들은 대규모의 서비스를 운영하고 있기 때문에 최대한 자원을 효율적으로 써야 비용적으로 유리하다.
그래서 서버 자원을 효율적으로 쓰기 위해서는 가상화 기술에 대해 관심을 가질 수 밖에 없는데, 쿠버네티스를 좀더 잘 이해하려면 가상화 기술들에 대한 히스토리를 알 필요가 있다.

1991년 리눅스의 자원격리기술(chroot, namespace, cgroup 등)
이후 VM(가상화기술) - VMware, KVM, Xen, Openstack
하지만 생각보다 시스템 효율이 안나는걸 느낌

가장 큰 원인은 VM가상화를 하기 위해 무거운 OS를 띄워야 하는 근본적 문제
가벼운 서비스를 하나 띄우기 위해 이보다 더 큰 OS를 띄우는 등의 문제가 있었음.

dotCloud라는 회사에서 2014년 Container(가상화기술)을 선보임 - 예전 리눅스의 자원격리 기술을 기반으로 하였음. 이전 리눅스의 자원격리 기술은 대중화되지 못했었음
이 화사가 Docker로 추후에 변경됨.
컨테이너 가상화 기술은 서비스간에 자원격리를 하는데 OS를 별도로 안 띄워도 된다.
OS기동시간이 없기 때문에 자동화시 빠르고 자원 효율 또한 매우 높다

Docker 자체는 하나의 서비스를 컨테이너로 가상화시켜서 배포를 하는것에 목적이 있다. 엄청 많은 서비스를 운영할 때 그것을 일일히 배포하고 운영하는 역할을 하진 않음.
이런걸 하는게 컨테이너 오케스트레이터라는 개념이고, 여러 컨테이너들을 관리하는 솔루션을 의미한다.
오케스트레이터에는 도커스웜, 랜처, Hashi Corp Nomad, K8s가 있으며 k8s가 늦게 릴리즈 되었으나 해당 프로젝트에 참여하는 기업들(레드햇, MS, IBM, Docker, MESOSPHERE 등)이 자신들의 노하우를 녹여내면서 퀄리티가 매우 높아졌음. 따라서 현재는 하나의 표준이라고 불릴수 있을 정도로 많이 사용됨.

## 2. Why K8S?
기업입장에서 새로운 서비스를 런칭하거나(예를 들어 게임) 여러 서비스를 동시에 운영하는 경우 트래픽에 대한 예측이 어렵고, 충분한 리소스를 사전에 확보하는 것도 어렵다.

기존의 운영방식은 서비스에 따라 수용할 수 있는 서버 자원을 확보해 놓는 반면, 쿠버네티스는 auto scling을 통해 트래픽이 높아지는 서비스에 대해서만 자원 할당을 늘릴 수 있다. 즉, 더 적은 서버자원으로도 원활한 서비스를 제공할 수 있음.
기존 시스템에 장애가 나는 경우 여분의 백업 서버가 있어 운영서버가 죽는경우 즉각 대응을 하는데 쿠버네티스가 적용된 서비스는 장애가 난 서버 위에 있는 서비스들이 다른 서버로 옮겨갈 수 있는 auto healing 기능이 있다.
버전을 올리는 경우는 중단이 가능하다면 모든 서버를 중지하고 한번에 업데이트를 하거나 무중단이 안되면 하나씩 서버를 업데이트 해야한다. 하지만 쿠버네티스 기반의 시스템은 Deployment라는 오브젝트(RollingUpdate, ReCreate)를 통해 자동으로 업데이트를 지원한다.
쿠버네티스 사용시 서비스 효율이 좋아지고 비용을 감소할 수 있다.

## 3. VM vs Container
VM : Host OS 위에 vm을 가상화하기 위해 Hypervisor(VMware, Xen, KVM 등)가 올라가고, 그 위해 Guest OS가 다시 올라가고, 그 위에 여러 어플리케이션을 설치하여 서비스 제공을 하는 방식.

Container : Host OS 위에 컨테이너 가상화를 지원하는 Docker, rkt, LXC와 같은 소프트웨어를 설치하고, 이 위에 컨테이너가 올라가게 된다.
도커는 여러 컨테이너들 간에 호스트 자원을 분리해서 사용할 수 있게한다. 이것이 리눅스 고유 기술인 namespace(mnt, pid, net, ipc, uts, user - 커널에 대한 영역을 분리)와 cgroups(memory, CPU, I/O, network - 자원에 대한 영역을 분리)를 사용하는 것이다.
단점 : vm은 윈도우를 사용하더라도 리눅스 guest os를 설치하면 리눅스 사용이 가능하다. 하지만 컨테이너는 리눅스에서 윈도우용 컨테이너를 사용할 수 없다. 또한 보안적으로도 vm은 하나의 guest os가 뚫려도 다른 guest os와 완벽히 분리가 되어 있기 때문에 각각의 vm끼리 피해가 가지 않지만, 컨테이너는 하나의 컨테이너가 뚫려 host os 영역에 접근을 하게되면 다른 컨테이너들에게 영향을 미칠 수 있다. 

## 4. Getting started - k8s

## 5. Overview
쿠버네티스는 서버한대는 master로 쓰고 다른 서버들은 node라고 해서 마스터에 여러 노드들이 연결이 된다. 이런 연결을 쿠버네티스 클러스터라고 한다.
master는 쿠버네티스의 전반적인 기능을 컨트롤하는 역할.
node들은 자원을 제공하는 역할.
클러스터 전체 자원을 늘리고 싶다면 노드들을 계속 추가하면된다.
클러스터 안에 namespace라는 것이 쿠버네티스 오브젝트들을 독립된 공간으로 분리되게 만들어 준다. namespace에는 쿠버네티스 최소 배포단위이 pod들이 있고, 이 pod들에게 외부에서 연결이 가능하도록 ip를 할당해 주는 service가 있다. 
서로 다른 namespace에 있는 pod는 연결할 수 없다. 
pod안에는 여러 컨테이너가 존재할 수 있다. 컨테이너 하나당 하나의 어플리케이션이 동작하기 때문에 결국 pod에는 여러 어플리케이션이 돌아갈 수 있다. 
하지만 pod에 문제가 생겨서 재생성이되면 그 안에 있는 데이터가 날아가게 되는데, volume을 사용하면 이곳에 데이터를 저장할 수 있다. 따라서 pod가 재생성되어도 데이터의 유지가 가능하다. 
namespace에 ResourceQuota/LimitRange를 달아서 namespace에서 사용할 수 있는 자원의 양을 한정시킬 수 있다. pod개수 제한, cpu나 메모리 제한도 가능
pod생성시에 컨테이너 안에 환경변수 값을 넣어주거나 파일을 마운팅할 수 있는데 ConfigMap/Secret을 사용하면 된다.
또한 Controller가 pod들을 관리하는 역할을 하게 되는데 종류가 여러가지가 있음.
Replication Controller, ReplicaSet은 가장 기본적인 컨트롤러이며 pod가 죽으면 감지해서 다시 재생성하거나 pod의 개수를 늘리거나 줄일 수 있다.
Deployment는 배포 후의 pod들을 새 벼전으로 업그레이드 해준다. 업그레이드 중 문제가 생기면 롤백을 쉽게할 수 있도록 도와준다.
DaemonSet은 한 노드에 pod가 하나씩만 유지가 되도록 한다.
CronJob은 어떤 특정 작업만 하고 종료시켜야하는경우 pod가 그 역할을 수행할 수 있도록 한다.

## 6. Pod
Pod 안에는 독립적인 서비스를 구동할 수 있는 컨테이너가 존재.
컨테이너들은 서비스가 연결될 수 있도록 포트를 가지고 있는데 한 컨테이너가 하나 이상의 포트를 사용할 수 있지만, 한 Pod 안에서 컨테이너들끼리 포트가 중복될 수 없다. 
Pod 내에서는 localhost 통신을 할 수 있음.
Pod 생성시 고유의 ip가 랜덤하게 할당되는데 쿠버네티스 클러스터 내에서만 해당 ip로 접근할 수 있다. (재생성시 변경됨. 즉 휘발성) . 외부에서는 pod의 ip로 직접접근이 안된다.

Label속성 : pod뿐만 아니라 모든 쿠버네티스 오브젝트에 달 수 있지만, pod를 정의할 때 가장 많이 사용된다. Lable을 사용하는 이유는 목적에 따라 오브젝트를 분류하고, 그 분류된 오브젝트들만 연결하기 위함이다. 
key:value 형태로 구성됨. 한 pod에는 여러개의 label을 달 수 있다. 
원하는 pod를 선택해서 service에서 따로 구성하여 사용하는 것이 가능하다. Service에서 selector를 사용해서 pod의 label을 구분지으면 됨.

Node Schedule : pod는 여러 노드중 한 노드에 올라가야하는데 직접 지정하는 방법과 쿠버네티스가 자동으로 지정하는 방법이 있다.

직접 지정하는 방법 : pod에 label을 단 것 처럼 node에 label을 달고 pod를 만들때 노드를 지정할 수 있다. nodeSelector를 사용하면 됨.

쿠버네티스의 스케줄러가 자동으로 지정하는 방법 : 쿠버네티스 스케줄러가 생성되는 pod의 리소스를 고려하여 여러 노드 중 가장 적합한 노드에 스케줄링한다.

## 7. Service
자신의 클러스터 ip를 가지고 있고, Service를 pod에 연결시켜 놓으면 Service ip를 통해서 pod에 접근할 수 있다. 
pod라는 존재는 언제던지 죽을 수 있고 다시 재생성되도록 설계되어 있는 오브젝트이다. 따라서 해당 pod가 죽고, 재생성되면 ip 할당 또한 달라진다.(신뢰성이 떨어짐)
service는 사용자가 삭제하는 것이 아닌 이상 삭제 되지 않기 때문에, Service를 사용한다.

ClusterIP : Cluster내에서만 접근 가능한 IP이다.(외부에서 직접 접속을 못함)
pod를 여러개 연결할 수 있는데, 여러개 연결시 service가 트래픽을 분산하여 pod에 전달한다.
외부에서 접근할 수 없고 클러스터 내부에서만 접근가능.
인가된 사용자(운영자), 내부 대시보드, pod의 서비스 상태 디버깅 용도로 사용

NodePort : Service에는 clusert ip가 할당이된다. 쿠버네티스 클러스터에 연결된 모든 노드에게 똑같은 포트가 할당되어 외부로부터 어떤 노드던 간에 ip와 포트로 접속을 하면 해당 service에 접속을 하고, 이 트래픽을 pod에 전달한다. 
모든 노드들에 포트가 할당되는 것이 특징이다.
물리적인 호스트의 ip를 통해서 pod에 접근이 가능. 일반적으로 물리적인 ip는 내부망에서만 접근할 수 있게 네트워크를 구성함.
내부망 연결, 데모나 임시 연결용

Load Balancer : Load balancer가 노드에 접근하는 트래픽을 분산을 해주어야 한다. Load Balancer에 접근을 하기 위한 외부 접속 ip는 쿠버네티스 설치만으로는 생성되지 않는다. 따라서 별도의 외부접속 ip를 할당해주는 플러그인이 설치되어 있어댜 해당 ip가 생긴다.
내부 ip가 노출되지 않고 외부 ip를 통해 안정적으로 서비스를 노출하기 위한 용도
외부시스템 노출용

## 8. Volume
emptyDir : 컨테이너들끼리 데이터를 공유하기 위해 volume을 사용하는 것.
volume은 pod 생성시 만들어지고 삭제시 없어진다.(pod안에 생성되는 volume이기 때문)
따라서 일시적인 사용목적에 의한 데이터만 넣어야 한다.

hostPath : pod들이 올라가 있는 Node의 path를 volume으로 사용.
Node 안에 생성되는 volume이기 때문에 pod들이 재생성되어도 영향을 받지 않는다. 
하지만 pod가 재생성될때 특정 노드에만 재생성 되는 것이 아닌, 스케줄러에 의해 가장 적합한 노드에 생성될 수도 있는데, 이러면 이전의 volume에 접근할 수 없다. 
hostpath이기 때문에 자신의 pod가 올라가있는 node의 volume만 사용하므로 다른 노드의 voluem을 마운트를 할 수가 없다. 하지만 굳이 방법을 찾는다면, 노드가 추가가 될 때마다 같은 이름의 경로를 만들어서 직접 노드에 있는 path끼리 마운트를 시켜주면 문제는 없어질 수 있다. 이 부분은 운영자가 직접 마운트를 연결해주어야 함.
각각의 노드에는 노드 자신들을 위해 사용되는 파일이 있을텐데 (시스템 파일, 설정파일 등) pod 자신이 할당되어 있는 호스트에 데이터를 읽거나 써야할 때 사용하면 된다. 
pod 생성전에 path가 미리 만들어져있어야 한다.(주의할점)

PVC(Persistent Volume Claim) / PV(Persistent Volume) : pod의 영속성있는 볼륨을 제공하기 위한 기능.

Pod -> Persistent Volume Claim -> Persistent Volume -> Volume(git, local storage 등)

직접 만들고 관리하는 솔루션(스토리지)을 각각 Persistent Volume을 정의하고 연결을 한다. 
Pod는 PV에 바로 연결하는 것이 아닌 PVC를 거쳐야 한다. 
PVC를 거치는 이유는 Volume 사용에 있어 user 영역(pod, PVC)과 admin 영역(PV, Volume)을 나누었기 때문이다.
admin은 쿠버네티스를 담당하는 운영자, user는 pod에 서비스를 만들고 배포를 관리하는 서비스 담당자.

