# Kubernetes

## 1. Summary
쿠버네티스를 큰 회사들이 꼭 써야하는 이유 : 큰 회사들은 대규모의 서비스를 운영하고 있기 때문에 최대한 자원을 효율적으로 써야 비용적으로 유리하다.
그래서 서버 자원을 효율적으로 쓰기 위해서는 가상화 기술에 대해 관심을 가질 수 밖에 없는데, 쿠버네티스를 좀더 잘 이해하려면 가상화 기술들에 대한 히스토리를 알 필요가 있다.

1991년 리눅스의 자원격리기술(chroot, namespace, cgroup 등)
이후 VM(가상화기술) - VMware, KVM, Xen, Openstack
하지만 생각보다 시스템 효율이 안나는걸 느낌

가장 큰 원인은 VM가상화를 하기 위해 무거운 OS를 띄워야 하는 근본적 문제
가벼운 서비스를 하나 띄우기 위해 이보다 더 큰 OS를 띄우는 등의 문제가 있었음.

dotCloud라는 회사에서 2014년 Container(가상화기술)을 선보임 - 예전 리눅스의 자원격리 기술을 기반으로 하였음. 이전 리눅스의 자원격리 기술은 대중화되지 못했었음
이 화사가 Docker로 추후에 변경됨.
컨테이너 가상화 기술은 서비스간에 자원격리를 하는데 OS를 별도로 안 띄워도 된다.
OS기동시간이 없기 때문에 자동화시 빠르고 자원 효율 또한 매우 높다

Docker 자체는 하나의 서비스를 컨테이너로 가상화시켜서 배포를 하는것에 목적이 있다. 엄청 많은 서비스를 운영할 때 그것을 일일히 배포하고 운영하는 역할을 하진 않음.
이런걸 하는게 컨테이너 오케스트레이터라는 개념이고, 여러 컨테이너들을 관리하는 솔루션을 의미한다.
오케스트레이터에는 도커스웜, 랜처, Hashi Corp Nomad, K8s가 있으며 k8s가 늦게 릴리즈 되었으나 해당 프로젝트에 참여하는 기업들(레드햇, MS, IBM, Docker, MESOSPHERE 등)이 자신들의 노하우를 녹여내면서 퀄리티가 매우 높아졌음. 따라서 현재는 하나의 표준이라고 불릴수 있을 정도로 많이 사용됨.

## 2. Why K8S?
기업입장에서 새로운 서비스를 런칭하거나(예를 들어 게임) 여러 서비스를 동시에 운영하는 경우 트래픽에 대한 예측이 어렵고, 충분한 리소스를 사전에 확보하는 것도 어렵다.

기존의 운영방식은 서비스에 따라 수용할 수 있는 서버 자원을 확보해 놓는 반면, 쿠버네티스는 auto scling을 통해 트래픽이 높아지는 서비스에 대해서만 자원 할당을 늘릴 수 있다. 즉, 더 적은 서버자원으로도 원활한 서비스를 제공할 수 있음.
기존 시스템에 장애가 나는 경우 여분의 백업 서버가 있어 운영서버가 죽는경우 즉각 대응을 하는데 쿠버네티스가 적용된 서비스는 장애가 난 서버 위에 있는 서비스들이 다른 서버로 옮겨갈 수 있는 auto healing 기능이 있다.
버전을 올리는 경우는 중단이 가능하다면 모든 서버를 중지하고 한번에 업데이트를 하거나 무중단이 안되면 하나씩 서버를 업데이트 해야한다. 하지만 쿠버네티스 기반의 시스템은 Deployment라는 오브젝트(RollingUpdate, ReCreate)를 통해 자동으로 업데이트를 지원한다.
쿠버네티스 사용시 서비스 효율이 좋아지고 비용을 감소할 수 있다.

## 3. VM vs Container
VM : Host OS 위에 vm을 가상화하기 위해 Hypervisor(VMware, Xen, KVM 등)가 올라가고, 그 위해 Guest OS가 다시 올라가고, 그 위에 여러 어플리케이션을 설치하여 서비스 제공을 하는 방식.

Container : Host OS 위에 컨테이너 가상화를 지원하는 Docker, rkt, LXC와 같은 소프트웨어를 설치하고, 이 위에 컨테이너가 올라가게 된다.
도커는 여러 컨테이너들 간에 호스트 자원을 분리해서 사용할 수 있게한다. 이것이 리눅스 고유 기술인 namespace(mnt, pid, net, ipc, uts, user - 커널에 대한 영역을 분리)와 cgroups(memory, CPU, I/O, network - 자원에 대한 영역을 분리)를 사용하는 것이다.
단점 : vm은 윈도우를 사용하더라도 리눅스 guest os를 설치하면 리눅스 사용이 가능하다. 하지만 컨테이너는 리눅스에서 윈도우용 컨테이너를 사용할 수 없다. 또한 보안적으로도 vm은 하나의 guest os가 뚫려도 다른 guest os와 완벽히 분리가 되어 있기 때문에 각각의 vm끼리 피해가 가지 않지만, 컨테이너는 하나의 컨테이너가 뚫려 host os 영역에 접근을 하게되면 다른 컨테이너들에게 영향을 미칠 수 있다. 

## 4. Getting started - k8s

## 5. Overview
쿠버네티스는 서버한대는 master로 쓰고 다른 서버들은 node라고 해서 마스터에 여러 노드들이 연결이 된다. 이런 연결을 쿠버네티스 클러스터라고 한다.
master는 쿠버네티스의 전반적인 기능을 컨트롤하는 역할.
node들은 자원을 제공하는 역할.
클러스터 전체 자원을 늘리고 싶다면 노드들을 계속 추가하면된다.
클러스터 안에 namespace라는 것이 쿠버네티스 오브젝트들을 독립된 공간으로 분리되게 만들어 준다. namespace에는 쿠버네티스 최소 배포단위이 pod들이 있고, 이 pod들에게 외부에서 연결이 가능하도록 ip를 할당해 주는 service가 있다. 
서로 다른 namespace에 있는 pod는 연결할 수 없다. 
pod안에는 여러 컨테이너가 존재할 수 있다. 컨테이너 하나당 하나의 어플리케이션이 동작하기 때문에 결국 pod에는 여러 어플리케이션이 돌아갈 수 있다. 
하지만 pod에 문제가 생겨서 재생성이되면 그 안에 있는 데이터가 날아가게 되는데, volume을 사용하면 이곳에 데이터를 저장할 수 있다. 따라서 pod가 재생성되어도 데이터의 유지가 가능하다. 
namespace에 ResourceQuota/LimitRange를 달아서 namespace에서 사용할 수 있는 자원의 양을 한정시킬 수 있다. pod개수 제한, cpu나 메모리 제한도 가능
pod생성시에 컨테이너 안에 환경변수 값을 넣어주거나 파일을 마운팅할 수 있는데 ConfigMap/Secret을 사용하면 된다.
또한 Controller가 pod들을 관리하는 역할을 하게 되는데 종류가 여러가지가 있음.
Replication Controller, ReplicaSet은 가장 기본적인 컨트롤러이며 pod가 죽으면 감지해서 다시 재생성하거나 pod의 개수를 늘리거나 줄일 수 있다.
Deployment는 배포 후의 pod들을 새 벼전으로 업그레이드 해준다. 업그레이드 중 문제가 생기면 롤백을 쉽게할 수 있도록 도와준다.
DaemonSet은 한 노드에 pod가 하나씩만 유지가 되도록 한다.
CronJob은 어떤 특정 작업만 하고 종료시켜야하는경우 pod가 그 역할을 수행할 수 있도록 한다.

## 6. Pod
